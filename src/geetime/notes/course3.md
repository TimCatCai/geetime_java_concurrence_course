# 03 | 互斥锁（上）：　解决原子性问题
原子性：　一个操作在cpu执行过程中不被中断的特性。
原子性问题的源头是线程切换，而操作系统做线程切换是依赖cpu中断的。

在单核时代，禁用cpu发生中断解决原子性是可行的。原因是同一时刻只有一个线程运行，
禁用cpu中断，也就禁用了操作系统重新调度线程，即禁用了线程切换。获取调度权的线程
就可以一直运行下去，所以一个语句可以保证原子性。

在多核时代，只能保证同一个cpu上线程的连续运行，而不能保证同一时刻只能有一个线程运行。

## 定义
互斥：　同一时刻只有一个线程执行。  
意义：　如果能够对共享变量的修改是互斥的，无论是单核还是多核，都能保证原子性。

## 简易锁模型
解决互斥问题的核心问题：锁。
### 定义
临界区：一段需要互斥执行的代码。  
### 过程
进入临界区之前先尝试加锁，成功则进入，否则等待，直到持有锁的线程解锁。
持有锁的线程执行完临界区的代码后，执行解锁unlock()。

## 改进后的锁模型
重点关注的点：我们锁的是什么？我们保护的又是什么。

