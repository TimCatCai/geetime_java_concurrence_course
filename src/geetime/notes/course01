# 01|可见性、原子性和有序性问题：并发编程的源头
编写正确的并发程序是一件极其困难的事情，并发程序的bug往往会诡异的出现，又会诡异的消失，很难重现，也很难追踪。
正确解决方法是溯源。  
为合理利用cpu高性能，平衡cpu io 内存之间的速度差距：  
1. 计算机体系结构方面：　增加了cpu缓存，　均衡cpu与内存之间的速度差异。   
2. 操作系统: 增加进程、线程等分时复用技术，均衡cpu与io之间的速度差异，提高cpu的利用率。  
3. 编译器方面：　优化指令执行次序，使缓存能够更合理地利用。  

# 源头之一：　缓存导致的可见性问题
## 定义：
可见性：　一个线程对共享变量的修改，另一个线程能够立刻看到。  

## 可见性问题原因
对于单核，所有线程操作是同一个cpu缓存，因而缓存与内存之间的一致性很容易保证。  
对于多核， 在不同cpu内核上执行的线程使用的是不同的cpu缓存。一个线程对同一变量执行的操作，对另一线程而言就不具可见性。  

## 具体例子
### 代码
```java
public class Course01 {
    private long count = 0;
    private void add1Billion(){
        // 当数据为1w, 10w时结果可能正确，因为不同的线程启动有一个时间差，
        // 而在这个时间差之内，一个线程的加法操作可能已经完成。
        // 而当数据逐渐增大时，发生缓存可见性问题的可能性变大
        for(int i = 0; i < 1000000000; i++){
            count ++;
        }
    }

    public static long calc(){
        final Course01 course01 = new Course01();
        // 启动两个线程对同一个变量进行加法操作
        Thread thread1 = new Thread(() -> course01.add1Billion());
        Thread thread2 = new Thread(() -> course01.add1Billion());
        thread1.start();
        thread2.start();
        try {
            //　等待两个线程的结束
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return course01.getCount();
    }

    public long getCount() {
        return count;
    }
}
```
### 分析
当两个线程的同时对count进行操作时，会从内存中将count的副本读入各自的cpu缓存，此时这两个线程对各自的
count副本进行操作，进行加一操作分别写回内存，从而内存得到的结果是１，而不是２。从而引发缓存的可见性问题。   

评论内容收获：  
加上volatile 关键字可以禁用缓存，运行速度会成倍下降   
但是最终结果仍不会是最终的结果，因而解决该问题不是简单的缓存可见性问题，可能还有原子问题　
# 线程切换带来的原子性问题
## 进程
任务切换：　经过一段固定的时间，操作系统会重新选择一个进程来执行。  
早期的操作系统是基于进程来切换，不同进程之间不共享内存空间，因而进程的切换意味着要切换内存映射地址。
## 线程
现代操作系统是基于线程来进行任务切换的，同一进程创建的不同线程共享一个内存空间。   
现在所提到的任务切换都是指线程切换。
## bug产生原因
高级语言里的一条语句往往需要多条cpu指令来进行。例如加一操作：  
指令１：将变量从内存加载到cpu寄存器  　
指令２：在寄存器中进行+1操作    
指令３：将结果写回内存（缓存机制导致可能写入的是cpu缓存而不是内存）   
操作系统做任务切换，可以发生在任何一条*cpu指令*执行完成，而不是*高级语言里的一条语句*。   
例如对于count做+1操作，线程A执行到指令1后发生线程切换，切换到线程B，线程B完成所有指令后再回到线程A,
线程A执行完之后就会将同样的+1值写回内存。
## 关键概念
原子性：一个或者多个操作在cpu执行的过程中不被中断的特性(cpu保证原子性操作是在cpu指令级别的，而不是
语句的操作符，也是违背常识，容易出bug的地方，因此很多时候需要在高级语言层面保证操作的原子性)。   
# 源头之三： 编译优化带来的有序性问题
经典问题： 双重检查创建单例对象。   
```java
public class Singleton{
    private static Singleton instance;
    public static Singleton getInstance(){
        if(instance == null){
            synchronized (Singleton.class){
                if(instance == null){
                    // 可能由于编译器优化带来空指针异常
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```
在new语句的时候，需要的操作是：   
1. 分配一块内存地址  
2. 在内存M上初始化Singleton对象   
3. 将M的地址赋值给instance变量   
而经编译器优化后的执行路径可能是：   
1. 分配一块内存地址    
2. 将M的地址赋值给instance变量   
3. 在内存M上初始化Singleton对象
因而就有可能在执行完2之后发生线程切换，但由于2先执行，因而在另一个线程引用未初始化的对象的成员变量时，
就有可能发生空指针异常。
# 思考题
在32位系统上进行long型的加减操作会带来并发问题：   
1. 注意这里是针对java来说，因而long型数据长度是64位，而不是c语言中，在32位系统上是可能是4个字节即32位。  
2. 正因为是固定的64位，在32位机器上，对数据的操作需要进行多条指令组合出来，无法保证原子性，因而带来并发问题。
# 总结
并发问题的诡异问题，通常是直觉欺骗了我们，在深入理解可见性、原子性和有序性问题后，很多并发bug都是可以理解和诊断的。  
缓存、线程切换和编译器优化，都是为了提高程序性能，但是又带了其他问题，由此，在技术解决一个问题的同时，必然会带来其他
问题，我们要清楚问题是什么，以及如何规避。
　